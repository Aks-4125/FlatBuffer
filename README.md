
### FlatBuffers Vs JSON

### FlatBuffer is too much faster than JSON.

### What are FlatBuffers?
FlatBuffers are an efficient cross platform serialization library for C++, C#, C, Go, Java, JavaScript, PHP, and Python. They were originally created at Google for game development, and other performance-critical applications.


### Implementation

JSON data is converted to FlatBuffer format somewhere outside the app (e.g. bin ary file is delivered as a file or returned directly from API)
Data model (Java classes) is generated by hand, with flatc (FlatBuffer compiler)
There are some limitations for JSON file (null fields cannot be used, Date format is parsed as a String)
Probably in the future we’ll prepare more complex solution.


### Why use FlatBuffers?
* Access to serialized data without parsing/unpacking — What sets FlatBuffers apart is that they represent hierarchical data in a flat binary buffer, in such a way that they can still be accessed directly without parsing and unpacking, while also still supporting data structure evolution (forwards/backwards compatibility).
* Memory efficiency and speed — The only memory needed to access your data is that of the buffer. It requires zero additional allocations (at least in C++. Other languages may vary). FlatBuffers are also suitable for use with mmap (or streaming), requiring only part of the buffer to be in memory. Access is close to the speed of raw struct access with only one extra indirection (a kind of vtable) to allow for format evolution and optional fields. FlatBuffers are aimed at projects where spending time and space (many memory allocations) to be able to access or construct serialized data is undesirable, such as in games, or any other performance sensitive applications. See the benchmarks for details.
* Flexible — Having optional fields mean that not only do you get great forwards and backwards compatibility (increasingly important for long-lived games: you don’t have to update all data with each new version). It also means you have a lot of choice in what data you write and what data you don’t, and how you design data structures.
* Tiny code footprint — FlatBuffers require only small amounts of generated code, and just a single small header as the minimum dependency, which is very easy to integrate. Again, see the benchmark section for details.
* Strongly typed — Errors happen at compile time rather than manually having to write repetitive and error prone run-time checks. Useful code can be generated for you.
* Convenient to use — Generated C++ code allows for terse access and construction code. Then there’s the optional functionality for parsing schemas, and JSON-like text representations at runtime run efficiently if you need them (faster and more memory efficient than other JSON parsers).
* Cross platform code with no dependencies — C++ code will work with any recent gcc/clang and VS2010. Comes with build files for the tests & samples (Android .mk files, and cmake for all other platforms).